

uint32_t klamath::MemoryStream::read_little_endian_u32() {
    return *((uint32_t*)read_then_advance(4));
}

uint32_t klamath::MemoryStream::read_big_endian_u32() {
    const uint8_t* ptrr = read_then_advance(4);
    return (ptrr[0] << 24) | (ptrr[1] << 16) | (ptrr[2] << 8) | (ptrr[3] << 0);
}

uint16_t klamath::MemoryStream::read_big_endian_u16() {
    const uint8_t* ptrr = (uint8_t*)read_then_advance(2);
    return (ptrr[0] << 8) | (ptrr[1] << 0);
}

int32_t klamath::MemoryStream::read_big_endian_i32() {
    // assumes data is using same signing method as CPU (2's complement)
    return read_big_endian_u32();
}

int16_t klamath::MemoryStream::read_big_endian_i16() {
    // assumes data is using same signing method as CPU (2's complement)
    return read_big_endian_u16();
}

std::vector<uint8_t> klamath::MemoryStream::read_n_bytes(size_t n) {
    const uint8_t* data = read_then_advance(n);

    std::vector<uint8_t> ret;
    ret.reserve(n);
    for (size_t i = 0; i < n; i++) {
        ret.push_back(data[i]);
    }

    return ret;
}